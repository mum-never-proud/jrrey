{"version":3,"sources":["utils/assert.js","utils/parser.js","utils/speech-event-handlers.js","constants/speech-recognition-options.js","utils/speech-recognition.js","constants/speech-events.js","jrrey.js"],"names":["assertFunction","input","TypeError","assertString","assertStringOrRegExp","RegExp","parseTranscripts","speech","Array","from","results","resultIndex","map","result","transcript","parseCommands","zippedCommands","commands","isArray","forEach","zippedCommand","Error","phrase","callback","push","speechEventHandler","speechEvent","keepAlive","type","listeningSince","Date","now","Number","window","setTimeout","start","resultHandler","call","events","transcripts","mode","Map","i","text","trim","command","idx","output","exec","set","get","length","size","entries","index","fallback","dictate","Object","freeze","lang","continuous","interimResults","maxAlternatives","speechRecognition","speechRecognitionVendor","SpeechRecognition","webkitSpeechRecognition","mozSpeechRecognition","msSpeechRecognition","oSpeechRecognition","assign","speechRecognitionOptions","boundSpeechEventHandler","Symbol","Jrrey","options","bind","addEventListener","abort","stop","event","filter","String","module","exports"],"mappings":"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","file":"jrrey.js","sourceRoot":"../src","sourcesContent":["export function assertFunction(input) {\n  if (typeof input !== 'function') {\n    throw TypeError('callback must be a function');\n  }\n}\n\nexport function assertString(input) {\n  if (typeof input !== 'string') {\n    throw TypeError('event must be a string');\n  }\n}\n\nexport function assertStringOrRegExp(input) {\n  if (typeof input !== 'string' && !(input instanceof RegExp)) {\n    throw TypeError('command must be either string or regex');\n  }\n}\n","import { assertStringOrRegExp, assertFunction } from './assert';\n\nexport function parseTranscripts(speech) {\n  return Array.from(speech.results[speech.resultIndex]).map(result => result.transcript);\n}\n\nexport function parseCommands(zippedCommands) {\n  const commands = [];\n\n  if (Array.isArray(zippedCommands)) {\n    zippedCommands.forEach(zippedCommand => {\n      if (Array.isArray(zippedCommand)) {\n        const [phrase, callback] = zippedCommand;\n\n        assertStringOrRegExp(phrase);\n        assertFunction(callback);\n\n        commands.push({ phrase, callback });\n      } else {\n        throw Error('commands should be a zipped array e.g [ [command, callback] ]')\n      }\n    });\n\n    return commands;\n  }\n\n  return commands;\n}\n","import { parseTranscripts } from './parser';\n\nexport default function speechEventHandler(speechEvent) {\n  if (this.keepAlive && speechEvent.type === 'end' && this.listeningSince) {\n    if (Date.now() - Number(this.listeningSince) < 1000) {\n      window.setTimeout(() => this.start(), 1000);\n    } else {\n      this.start();\n    }\n  } else {\n    switch (speechEvent.type) {\n      case 'result':\n        resultHandler.call(this, speechEvent);\n\n        return;\n      default:\n        const callback = this.events[speechEvent.type];\n\n        if (typeof callback === 'function') {\n          callback(speechEvent);\n        }\n    }\n  }\n}\n\nfunction resultHandler(speech) {\n  const transcripts = parseTranscripts(speech);\n\n  if (this.mode === 'cmd') {\n    const results = new Map();\n\n    for (let i = 0; i < transcripts.length; i++) {\n      const text = transcripts[i].trim();\n\n      this.commands.forEach((command, idx) => {\n        const output = command.phrase instanceof RegExp\n          ? command.phrase.exec(text)\n          : command.phrase === text ? text : null\n\n        if (output) {\n          results.set(idx, (results.get(idx) || [])).get(idx).push(output);\n        }\n      });\n    }\n\n    if (results.size) {\n      for (const [index, output] of results.entries()) {\n        this.commands[index].callback(output);\n      }\n    } else if (typeof this.events.fallback === 'function') {\n      this.events.fallback();\n    }\n  } else if (typeof this.events.dictate === 'function') {\n    this.events.dictate(transcripts);\n  }\n}\n","export default Object.freeze({\n  lang: 'en-US',\n  continuous: true,\n  interimResults: false,\n  maxAlternatives: 3\n});\n","import speechRecognitionOptions from '../constants/speech-recognition-options';\n\nconst speechRecognitionVendor = window.SpeechRecognition\n  || window.webkitSpeechRecognition\n  || window.mozSpeechRecognition\n  || window.msSpeechRecognition\n  || window.oSpeechRecognition;\n\nif (!speechRecognitionVendor) {\n  throw Error('SpeechRecognition not supported in this browser');\n}\n\nconst speechRecognition = new speechRecognitionVendor();\n\nObject.assign(speechRecognition, speechRecognitionOptions);\n\nexport default speechRecognition;\n","export default [\n  'start',\n  'end',\n  'audiostart',\n  'audioend',\n  'speechstart',\n  'speechend',\n  'result',\n  'error',\n  'nomatch'\n];\n","import { assertFunction, assertString, assertStringOrRegExp } from './utils/assert';\nimport { parseCommands } from './utils/parser';\nimport speechEventHandler from './utils/speech-event-handlers';\nimport speechRecognition from './utils/speech-recognition';\nimport speechEvents from './constants/speech-events';\n\nconst boundSpeechEventHandler = Symbol();\n\nclass Jrrey {\n  init(options = {}) {\n    if (this.listeningSince) {\n      throw Error('an instance of jrrey is already running');\n    }\n\n    this.events = options.events || {};\n    this.commands = parseCommands(options.commands);\n    this.mode = options.mode || 'cmd';\n    this.keepAlive = options.keepAlive || true;\n    this[boundSpeechEventHandler] = speechEventHandler.bind(this);\n\n    speechEvents.forEach(speechEvent => speechRecognition.addEventListener(speechEvent, this[boundSpeechEventHandler]));\n\n    return this;\n  }\n\n  start() {\n    this.listeningSince = Date.now();\n\n    speechRecognition.abort();\n    speechRecognition.start();\n\n    return this;\n  }\n\n  stop() {\n    this.listeningSince = null;\n\n    speechRecognition.stop();\n\n    return this;\n  }\n\n  onEvent(event, callback) {\n    assertString(event);\n    assertFunction(callback);\n\n    this.events[event] = callback;\n\n    return this;\n  }\n\n  offEvent(event) {\n    if (!event) {\n      this.events = {};\n    } else {\n      assertString(event);\n\n      delete this.events[event];\n    }\n\n    return this;\n  }\n\n  onCommand(phrase, callback) {\n    assertStringOrRegExp(phrase);\n    assertFunction(callback);\n\n    this.commands.push({ phrase, callback });\n\n    return this;\n  }\n\n  offCommand(phrase) {\n    if (!phrase) {\n      this.commands = [];\n    } else {\n      assertStringOrRegExp(phrase);\n\n      this.commands = this.commands.filter(command => String(command.phrase) !== String(phrase));\n    }\n\n    return this;\n  }\n}\n\nmodule.exports = new Jrrey();\n"]}